---
title: "Customized distance functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Customized distance functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this example, we demonstrate how customized distance functions can be used in counterfactual methods (e.g. `MOCClassif`)
and the resulting `Counterfactuals` object. <br>
By default, `MOCClassif` uses the Gower distance (Gower 1971) for the second and forth MOC objective (Dandl et al. 2020). 
In this example we want to use the scaled euclidean distance instead. 

### Set up

```{r example, message=FALSE}
library(counterfactuals)
library(randomForest)
library(iml)
```

```{r}
rf = randomForest(Species ~ ., data = iris[-150L, ])
predictor = Predictor$new(rf, type = "prob")
x_interest = iris[150L, ]
```

### Customize the distance function in counterfactual methods

A new distance function must have three arguments: `x`, `y`, and `data`, and it must return a `numeric` 
matrix with `nrow(x)` rows and `nrow(y)` columns.  <br>
Internally, for `MOCClassif`:

- `x` is set to the individuals of the current generation
- `y` is set to `x_interest` for the second objective and to the `k` nearest training points for the fourth objective
- `data` is set to `predictor$data$X`, which can be used to calculate the statistics used by the distance measure, e.g., 
the standard deviations or value ranges.

All arguments are passed as `data.table`s.


```{r}
scaled_euclidean_distance = function(x, y, data) {
  means = data[, lapply(.SD, mean)]
  sds = data[, lapply(.SD, sd)]
  x_scaled = scale(x, center = means, scale = sds)
  y_scaled = scale(y, center = means, scale = sds)
  
  res = matrix(NA, nrow = nrow(x_scaled), ncol = nrow(y_scaled))
  for (i in seq_len(nrow(x_scaled))) {
    for (j in seq_len(nrow(y_scaled))) {
      res[i, j] = sqrt(sum(((x_scaled[i, ] - y_scaled[j, ])^2)))
    }
  }
  res
}
```

Then we pass our distance function to `MOCClassif` with the `distance_function` argument.

```{r}
moc_classif = MOCClassif$new(
  predictor, 
  n_generations = 10L, 
  distance_function = scaled_euclidean_distance
)
```

`MOCClassif` now uses the scaled euclidean distance for the second and forth MOC objective.

```{r, results='hide', message=FALSE}
cfactuals = moc_classif$find_counterfactuals(
  x_interest, 
  desired_class = "versicolor",
  desired_prob = c(0.5, 1)
)
```


### Customize the distance function in the Counterfactuals object

By default, the `Counterfactuals$evaluate` method uses the Gower distance to compute the second and forth evaluation 
measure. <br>
This can be customized by setting the `distance_function` active binding.

```{r}
cfactuals$distance_function = scaled_euclidean_distance
```

```{r}
head(cfactuals$evaluate(), 3L)
```


## References

Dandl, Susanne, Christoph Molnar, Martin Binder, and Bernd Bischl. 2020. “MultiObjective Counterfactual Explanations.” In Parallel Problem Solving from Nature – PPSN XVI, edited by Thomas Bäck, Mike Preuss, André Deutz, Hao Wang, Carola Doerr, Michael Emmerich, and Heike Trautmann, 448–69. Cham: Springer International Publishing.

Gower, J. C. (1971), "A general coefficient of similarity and some of its properties". Biometrics, 27, 623–637.


